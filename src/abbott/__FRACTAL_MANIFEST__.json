{
  "manifest_version": "2",
  "task_list": [
    {
      "name": "Compute Registration (elastix)",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing"
      ],
      "docs_info": "### Purpose\n- **Computes image-based registration** transformations for acquisitions in **HCS** OME-Zarr datasets using the elastix library.\n- Needs Elastix profiles to configure the registration.\n- Calculates registration transforms e.g. per FOV by providing FOV_ROI_table.\n- Can handle cases where there are more than one embryo / organoid in a FOV if each ROI e.g. embryo / organoid is masked by a linked label (e.g. calculated by`scMultiplex Calculate Object Linking`) and corresponding masking_roi_table. Assumes label_id to be the same across cycles, but soesn't require FOVs to have the same shape.\n- Typically used as the first task in a workflow, followed by `Apply Registration (elastix)`.\n\n### Output\n- Calculates transformation parameters for **per (ROI)** and stores the results in a registration subfolder of OME-Zarr container.\n\n### Limitations\n- Supports only HCS OME-Zarr datasets, leveraging their acquisition metadata and well-based image grouping.\n",
      "type": "compound",
      "executable_non_parallel": "fractal_tasks/init_registration_hcs.py",
      "executable_parallel": "fractal_tasks/compute_registration_elastix.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitRegistrationHcs"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be used for registration. Choose `0` to process at full resolution. Currently only level 0 is supported."
          },
          "ref_wavelength_id": {
            "title": "Ref Wavelength Id",
            "type": "string",
            "description": "Wavelength that will be used for image-based registration as the reference; e.g. `A01_C01` for Yokogawa, `C01` for MD."
          },
          "mov_wavelength_id": {
            "title": "Mov Wavelength Id",
            "type": "string",
            "description": "(Optional) wavelength that will be used for image-based registration for moving images; e.g. `A01_C01` for Yokogawa, `C01` for MD."
          },
          "parameter_files": {
            "items": {
              "type": "string"
            },
            "title": "Parameter Files",
            "type": "array",
            "description": "Paths to the elastix parameter files to be used. List order is order of registration. E.g. parse first rigid, then affine and lastly bspline."
          },
          "lower_rescale_quantile": {
            "default": 0.0,
            "title": "Lower Rescale Quantile",
            "type": "number",
            "description": "Lower quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0."
          },
          "upper_rescale_quantile": {
            "default": 0.99,
            "title": "Upper Rescale Quantile",
            "type": "number",
            "description": "Upper quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0.99."
          },
          "roi_table": {
            "default": "FOV_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "use_masks": {
            "default": false,
            "title": "Use Masks",
            "type": "boolean",
            "description": " If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within `embryo_ROI_table`)."
          },
          "masking_label_name": {
            "title": "Masking Label Name",
            "type": "string",
            "description": "Optional label for masking ROI e.g. `embryo`."
          },
          "skip_failed_rois": {
            "default": true,
            "title": "Skip Failed Rois",
            "type": "boolean",
            "description": "If `True`, ROIs that fail during registration will be skipped and the task will continue with the next ROI. An identity transformation will be written for the failed ROIs and a condition table will be added to the OME-Zarr listing the ROIs with issues."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "ref_wavelength_id",
          "parameter_files"
        ],
        "type": "object",
        "title": "ComputeRegistrationElastix"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Apply Registration (elastix)",
      "output_types": {
        "registered": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing"
      ],
      "docs_info": "### Purpose\n- **Applies pre-calculated registration** from `Compute Registration (elastix)` task to images in an **HCS** OME-Zarr dataset, aligning all acquisitions to a specified reference acquisition.\n- Replaces the non-aligned image with the newly aligned image in the dataset if `overwrite input` is selected.\n- Typically used as the second task in a workflow, following `Compute Registration (elastix)`.\n\n### Limitations\n- If `overwrite input` is selected, the non-aligned image is permanently deleted, which may impact workflows requiring access to the original images.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/apply_registration_elastix.py",
      "meta_parallel": {
        "cpus_per_task": 16,
        "mem": 60000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          },
          "output_image_suffix": {
            "default": "registered",
            "title": "Output Image Suffix",
            "type": "string",
            "description": "Name of the output image suffix. E.g. \"registered\"."
          },
          "roi_table": {
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table which has been used during computation of registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "use_masks": {
            "default": false,
            "title": "Use Masks",
            "type": "boolean",
            "description": "If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should be loaded."
          },
          "masking_label_name": {
            "title": "Masking Label Name",
            "type": "string",
            "description": "Name of the label that will be used for masking. If `use_masks=True`, the label image will be used to mask the bounding box of the ROI table. If `use_masks=False`, the whole bounding box will be loaded."
          },
          "overwrite_input": {
            "default": true,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "Whether the old image data should be replaced with the newly registered image data."
          }
        },
        "required": [
          "zarr_url",
          "roi_table"
        ],
        "type": "object",
        "title": "ApplyRegistrationElastix"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Compute Registration (warpfield)",
      "input_types": {
        "is_3D": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Computes image-based registration** transformations for acquisitions in **HCS** OME-Zarr datasets based on [warpfield](https://github.com/danionella/warpfield).\n- Takes warpfield registration recipe, if None is provided default registration recipe is applied. \n- Can handle cases where there are more than one embryo / organoid in a FOV if each ROI e.g. embryo / organoid is masked by a linked label (e.g. calculated by`scMultiplex Calculate Object Linking`) and corresponding masking_roi_table. Assumes label_id to be the same across cycles, but doesn't require FOVs to have the same shape.\n- Typically used as the first task in a workflow, followed by `Apply Registration (warpfield)`.\n\n### Output\n- Calculates transformation **warpmap per (ROI)** and stores the results in a registration subfolder of the OME-Zarr container.\n\n### Limitations\n- Supports only HCS OME-Zarr datasets, leveraging their acquisition metadata and well-based image grouping.\n- Requires GPU with Cuda > 11.x .\n- For **Pelkmans cluster** the following parameters need to be provided manually during Worker Initialisation:\n    ```\n    export NVCC_PREPEND_FLAGS=\"--std=c++17\"\n    ```\n",
      "type": "compound",
      "executable_non_parallel": "fractal_tasks/init_registration_hcs.py",
      "executable_parallel": "fractal_tasks/compute_registration_warpfield.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000,
        "needs_gpu": true
      },
      "args_schema_non_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. Not used by this task. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Needs to match the acquisition metadata in the OME-Zarr image."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir"
        ],
        "type": "object",
        "title": "InitRegistrationHcs"
      },
      "args_schema_parallel": {
        "$defs": {
          "InitArgsRegistration": {
            "description": "Registration init args.",
            "properties": {
              "reference_zarr_url": {
                "title": "Reference Zarr Url",
                "type": "string"
              }
            },
            "required": [
              "reference_zarr_url"
            ],
            "title": "InitArgsRegistration",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsRegistration",
            "title": "Init Args",
            "description": "Intialization arguments provided by `image_based_registration_hcs_init`. They contain the reference_zarr_url that is used for registration. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "level": {
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be used for registration."
          },
          "wavelength_id": {
            "title": "Wavelength Id",
            "type": "string",
            "description": "Wavelength that will be used for image-based registration; e.g. `A01_C01` for Yokogawa, `C01` for MD."
          },
          "histogram_normalisation": {
            "default": true,
            "title": "Histogram Normalisation",
            "type": "boolean",
            "description": "If `True`, applies histogram normalisation to the moving image before calculating the registration. Default: `True`."
          },
          "path_to_registration_recipe": {
            "title": "Path To Registration Recipe",
            "type": "string",
            "description": "Path to the warpfield .yml registration recipe. This parameter is optional, if not provided, the default .yml recipe will be used."
          },
          "save_reg_video": {
            "default": false,
            "title": "Save Reg Video",
            "type": "boolean",
            "description": "If `True`, saves the video showing the registration in registration folder. Default: `False`."
          },
          "roi_table": {
            "default": "FOV_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "use_masks": {
            "default": false,
            "title": "Use Masks",
            "type": "boolean",
            "description": " If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within `embryo_ROI_table`)."
          },
          "masking_label_name": {
            "title": "Masking Label Name",
            "type": "string",
            "description": "Optional label for masking ROI e.g. `embryo`."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite existing registration files. Default: `False`."
          }
        },
        "required": [
          "zarr_url",
          "init_args",
          "level",
          "wavelength_id"
        ],
        "type": "object",
        "title": "ComputeRegistrationWarpfield"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Apply Registration (warpfield)",
      "input_types": {
        "is_3D": true
      },
      "output_types": {
        "registered": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Applies pre-calculated registration** from `Compute Registration (warpfield)` task to images in an **HCS** OME-Zarr dataset, aligning all acquisitions to a specified reference acquisition.\n- Replaces the non-aligned image with the newly aligned image in the dataset if `overwrite input` is selected.\n- Typically used as the second task in a workflow, following `Compute Registration (warpfield)`.\n\n### Limitations\n- If `overwrite input` is selected, the non-aligned image is permanently deleted, which may impact workflows requiring access to the original images.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/apply_registration_warpfield.py",
      "meta_parallel": {
        "cpus_per_task": 16,
        "mem": 60000,
        "needs_gpu": true
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_acquisition": {
            "default": 0,
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "Which acquisition to register against. Uses the OME-NGFF HCS well metadata acquisition keys to find the reference acquisition."
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Which resolution level to apply the registration on. Must match the level that was used during computation of the registration."
          },
          "output_image_suffix": {
            "default": "registered",
            "title": "Output Image Suffix",
            "type": "string",
            "description": "Name of the output image suffix. E.g. \"registered\"."
          },
          "roi_table": {
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table which has been used during computation of registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "use_masks": {
            "default": false,
            "title": "Use Masks",
            "type": "boolean",
            "description": "If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should be loaded."
          },
          "masking_label_name": {
            "title": "Masking Label Name",
            "type": "string",
            "description": "Name of the label that will be used for masking. If `use_masks=True`, the label image will be used to mask the bounding box of the ROI table. If `use_masks=False`, the whole bounding box will be loaded."
          },
          "overwrite_input": {
            "default": true,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "Whether the old image data should be replaced with the newly registered image data."
          }
        },
        "required": [
          "zarr_url",
          "roi_table"
        ],
        "type": "object",
        "title": "ApplyRegistrationWarpfield"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Compute Channel Registration (elastix)",
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Computes image-based registration** transformations for acquisitions in **HCS** OME-Zarr datasets using the elastix library.\n- Needs Elastix profiles to configure the registration.\n- Processes images grouped by well, under the assumption that each well contains one image per acquisition.\n- Calculates transformations for **specified regions of interest (ROIs)** and stores the results in a registration subfolder per OME-Zarr image.\n- Typically used as the first task in a workflow, followed by `Apply Channel Registration (elastix)`.\n\n### Limitations\n- Supports only HCS OME-Zarr datasets, leveraging their acquisition metadata and well-based image grouping.\n- Assumes each well contains a single image per acquisition.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/compute_channel_registration_elastix.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "reference_wavelength": {
            "title": "Reference Wavelength",
            "type": "string",
            "description": "Wavelength that will be used for image-based registration; e.g. `A01_C01` for Yokogawa, `C01` for MD."
          },
          "parameter_files": {
            "items": {
              "type": "string"
            },
            "title": "Parameter Files",
            "type": "array",
            "description": "Paths to the elastix parameter files to be used. Usually a single parameter file with the transformation class SimilarityTransform to compute channel registration."
          },
          "lower_rescale_quantile": {
            "default": 0.0,
            "title": "Lower Rescale Quantile",
            "type": "number",
            "description": "Lower quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0."
          },
          "upper_rescale_quantile": {
            "default": 0.99,
            "title": "Upper Rescale Quantile",
            "type": "number",
            "description": "Upper quantile for rescaling the image intensities before applying registration. Can be helpful to deal with image artifacts. Default is 0.99."
          },
          "roi_table": {
            "default": "FOV_ROI_table",
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to calculate the registration. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "level": {
            "default": 2,
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be used for registration. Choose `0` to process at full resolution."
          }
        },
        "required": [
          "zarr_url",
          "reference_wavelength",
          "parameter_files"
        ],
        "type": "object",
        "title": "ComputeChannelRegistrationElastix"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Apply Channel Registration (elastix)",
      "input_types": {
        "channels_registered": false
      },
      "output_types": {
        "channels_registered": true
      },
      "category": "Registration",
      "modality": "HCS",
      "tags": [
        "Multiplexing",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Applies pre-calculated registration** from `Calculate Channel Registration (elastix)` task to images in an **HCS** OME-Zarr dataset, aligning all channels of an acquisition to a specified reference wavelength.\n- This task is useful if there are wavelength- and sample-dependent chromatic shifts.\n- Replaces the non-aligned image with the newly aligned image in the dataset if `overwrite input` is selected.\n- Typically used as the second task in a workflow, following `Calculate Channel Registration (elastix)`.\n\n### Limitations\n- If `overwrite input` is selected, the non-aligned image is permanently deleted, which may impact workflows requiring access to the original images.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/apply_channel_registration_elastix.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "roi_table": {
            "title": "Roi Table",
            "type": "string",
            "description": "Name of the ROI table for which registrations have been calculated using the Compute Registration Elastix task. Examples: `FOV_ROI_table` => loop over the field of views, `well_ROI_table` => process the whole well as one image."
          },
          "reference_wavelength": {
            "title": "Reference Wavelength",
            "type": "string",
            "description": "Against which wavelength the registration was calculated."
          },
          "level": {
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of full resolution image. Currently, running all tasks at resolution level=0 is recommended."
          },
          "overwrite_input": {
            "default": true,
            "title": "Overwrite Input",
            "type": "boolean",
            "description": "Whether the old image data should be replaced with the newly registered image data. Currently only implemented for `overwrite_input=True`."
          },
          "overwrite_output": {
            "default": true,
            "title": "Overwrite Output",
            "type": "boolean",
            "description": "Whether pre-existing registered images (which will be named \"zarr_url\" + channel_registered) should be overwritten by the task."
          }
        },
        "required": [
          "zarr_url",
          "roi_table",
          "reference_wavelength",
          "level"
        ],
        "type": "object",
        "title": "ApplyChannelRegistrationElastix"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Convert Cellvoyager Multiplexing to existing OME-Zarr",
      "category": "Conversion",
      "modality": "HCS",
      "tags": [
        "Yokogawa",
        "Cellvoyager",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- Converts **multiplexed 2D and 3D images from CellVoyager CV7000/8000** systems into OME-Zarr format, storing each acquisition as a separate OME-Zarr image, **extending an existing** OME-Zarr plate.\n- Creates **OME-Zarr HCS plates**, combining all fields of view for each acquisition in a well into a single image.\n- Saves Fractal **region-of-interest (ROI) tables** for both individual fields of view and the entire well.\n- Handles overlapping fields of view by adjusting their positions to be non-overlapping, while preserving the original position data as additional columns in the ROI tables.\n\n### Limitations\n- This task currently does not support time-resolved data and ignores the time fields in CellVoyager metadata.\n",
      "type": "compound",
      "executable_non_parallel": "fractal_tasks/cellvoyager_to_ome_zarr_init_extend_multiplex.py",
      "executable_parallel": "fractal_tasks/cellvoyager_compute_omezarr.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "MultiplexingAcquisition": {
            "description": "Input class for Multiplexing Cellvoyager converter",
            "properties": {
              "image_dir": {
                "title": "Image Dir",
                "type": "string"
              },
              "allowed_channels": {
                "items": {
                  "$ref": "#/$defs/OmeroChannel"
                },
                "title": "Allowed Channels",
                "type": "array"
              }
            },
            "required": [
              "image_dir",
              "allowed_channels"
            ],
            "title": "MultiplexingAcquisition",
            "type": "object"
          },
          "OmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string"
              },
              "index": {
                "title": "Index",
                "type": "integer"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "window": {
                "allOf": [
                  {
                    "$ref": "#/$defs/Window"
                  }
                ],
                "title": "Window"
              },
              "color": {
                "title": "Color",
                "type": "string"
              },
              "active": {
                "default": true,
                "title": "Active",
                "type": "boolean"
              },
              "coefficient": {
                "default": 1,
                "title": "Coefficient",
                "type": "integer"
              },
              "inverted": {
                "default": false,
                "title": "Inverted",
                "type": "boolean"
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "OmeroChannel",
            "type": "object"
          },
          "Window": {
            "description": "Custom class for Omero-channel window, based on OME-NGFF v0.4.",
            "properties": {
              "min": {
                "title": "Min",
                "type": "integer"
              },
              "max": {
                "title": "Max",
                "type": "integer"
              },
              "start": {
                "title": "Start",
                "type": "integer"
              },
              "end": {
                "title": "End",
                "type": "integer"
              }
            },
            "required": [
              "start",
              "end"
            ],
            "title": "Window",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_urls": {
            "items": {
              "type": "string"
            },
            "title": "Zarr Urls",
            "type": "array",
            "description": "List of paths or urls to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path to the directory of the existing OME-Zarr file where the new acquisitions will be added. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "acquisitions": {
            "additionalProperties": {
              "$ref": "#/$defs/MultiplexingAcquisition"
            },
            "title": "Acquisitions",
            "type": "object",
            "description": "dictionary of acquisitions. Each key is the acquisition identifier (normally 0, 1, 2, 3 etc.). Each item defines the acquisition by providing the image_dir and the allowed_channels."
          },
          "include_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Include Glob Patterns",
            "type": "array",
            "description": "If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: `image_glob_pattern=[\"*_B03_*\"]` => only process well B03 `image_glob_pattern=[\"*_C09_*\", \"*F016*\", \"*Z[0-5][0-9]C*\"]` => only process well C09, field of view 16 and Z planes 0-59. Can interact with exclude_glob_patterns: All included images - all excluded images gives the final list of images to process"
          },
          "exclude_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Exclude Glob Patterns",
            "type": "array",
            "description": "If specified, exclude any image where the filename matches any of the exclusion patterns. Patterns are specified the same as for include_glob_patterns."
          },
          "num_levels": {
            "default": 5,
            "title": "Num Levels",
            "type": "integer",
            "description": "Number of resolution-pyramid levels. If set to `5`, there will be the full-resolution level and 4 levels of downsampled images."
          },
          "coarsening_xy": {
            "default": 2,
            "title": "Coarsening Xy",
            "type": "integer",
            "description": "Linear coarsening factor between subsequent levels. If set to `2`, level 1 is 2x downsampled, level 2 is 4x downsampled etc."
          },
          "image_extension": {
            "default": "tif",
            "title": "Image Extension",
            "type": "string",
            "description": "Filename extension of images (e.g. `\"tif\"` or `\"png\"`)."
          },
          "metadata_table_files": {
            "additionalProperties": {
              "type": "string"
            },
            "title": "Metadata Table Files",
            "type": "object",
            "description": "If `None`, parse Yokogawa metadata from mrf/mlf files in the input_path folder; else, a dictionary of key-value pairs like `(acquisition, path)` with `acquisition` a string like the key of the `acquisitions` dict and `path` pointing to a csv file containing the parsed metadata table."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_urls",
          "zarr_dir",
          "acquisitions"
        ],
        "type": "object",
        "title": "CellvoyagerToOmeZarrInitExtendMultiplex"
      },
      "args_schema_parallel": {
        "$defs": {
          "ChunkSizes": {
            "description": "Chunk size settings for OME-Zarrs.",
            "properties": {
              "t": {
                "title": "T",
                "type": "integer"
              },
              "c": {
                "default": 1,
                "title": "C",
                "type": "integer"
              },
              "z": {
                "default": 10,
                "title": "Z",
                "type": "integer"
              },
              "y": {
                "title": "Y",
                "type": "integer"
              },
              "x": {
                "title": "X",
                "type": "integer"
              }
            },
            "title": "ChunkSizes",
            "type": "object"
          },
          "InitArgsCellVoyager": {
            "description": "Arguments to be passed from cellvoyager converter init to compute",
            "properties": {
              "image_dir": {
                "title": "Image Dir",
                "type": "string"
              },
              "plate_prefix": {
                "title": "Plate Prefix",
                "type": "string"
              },
              "well_ID": {
                "title": "Well Id",
                "type": "string"
              },
              "image_extension": {
                "title": "Image Extension",
                "type": "string"
              },
              "include_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Include Glob Patterns",
                "type": "array"
              },
              "exclude_glob_patterns": {
                "items": {
                  "type": "string"
                },
                "title": "Exclude Glob Patterns",
                "type": "array"
              },
              "acquisition": {
                "title": "Acquisition",
                "type": "integer"
              }
            },
            "required": [
              "image_dir",
              "plate_prefix",
              "well_ID",
              "image_extension"
            ],
            "title": "InitArgsCellVoyager",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsCellVoyager",
            "title": "Init Args",
            "description": "Intialization arguments provided by `create_cellvoyager_ome_zarr_init`."
          },
          "chunk_sizes": {
            "$ref": "#/$defs/ChunkSizes",
            "title": "Chunk Sizes",
            "description": "Used to overwrite the default chunk sizes for the OME-Zarr. By default, the task will chunk the same as the microscope field of view size, with 10 z planes per chunk. For example, that can mean c: 1, z: 10, y: 2160, x:2560"
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "CellvoyagerComputeOmezarr"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Stardist Segmentation",
      "category": "Segmentation",
      "tags": [
        "Deep Learning",
        "Convolutional Neural Network",
        "Instance Segmentation",
        "2D",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Segments images using Stardist models**.\n- Supports both **built-in Stardist models** (shipped with Stardist) and **user-trained models**.\n- Accepts single channel image input for segmentation.\n- Can process **arbitrary regions of interest (ROIs)**, including whole images, fields of view (FOVs), or masked outputs from prior segmentations, based on corresponding ROI tables.\n- Provides access to all advanced Stardist parameters.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/stardist_segmentation.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000,
        "needs_gpu": true
      },
      "args_schema_parallel": {
        "$defs": {
          "StardistChannelInputModel": {
            "description": "Channel input for Stardist with normalization options.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "normalization": {
                "$ref": "#/$defs/StardistCustomNormalizer",
                "title": "Normalization"
              }
            },
            "title": "StardistChannelInputModel",
            "type": "object"
          },
          "StardistCustomNormalizer": {
            "description": "Validator to handle different normalization scenarios for Stardist models",
            "properties": {
              "norm_type": {
                "default": "default",
                "enum": [
                  "default",
                  "custom",
                  "no_normalization"
                ],
                "title": "Norm Type",
                "type": "string"
              },
              "lower_percentile": {
                "maximum": 100.0,
                "minimum": 0.0,
                "title": "Lower Percentile",
                "type": "number"
              },
              "upper_percentile": {
                "maximum": 100.0,
                "minimum": 0.0,
                "title": "Upper Percentile",
                "type": "number"
              },
              "lower_bound": {
                "title": "Lower Bound",
                "type": "integer"
              },
              "upper_bound": {
                "title": "Upper Bound",
                "type": "integer"
              }
            },
            "title": "StardistCustomNormalizer",
            "type": "object"
          },
          "StardistModelParams": {
            "description": "Advanced Stardist Model Parameters",
            "properties": {
              "sparse": {
                "default": true,
                "title": "Sparse",
                "type": "boolean"
              },
              "prob_thresh": {
                "title": "Prob Thresh",
                "type": "number"
              },
              "nms_thresh": {
                "title": "Nms Thresh",
                "type": "number"
              },
              "scale": {
                "default": [
                  1.0,
                  1.0,
                  1.0
                ],
                "maxItems": 3,
                "minItems": 3,
                "prefixItems": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "number"
                  },
                  {
                    "type": "number"
                  }
                ],
                "title": "Scale",
                "type": "array"
              },
              "n_tiles": {
                "default": [
                  1,
                  1,
                  1
                ],
                "maxItems": 3,
                "minItems": 3,
                "prefixItems": [
                  {
                    "type": "integer"
                  },
                  {
                    "type": "integer"
                  },
                  {
                    "type": "integer"
                  }
                ],
                "title": "N Tiles",
                "type": "array"
              },
              "show_tile_progress": {
                "default": false,
                "title": "Show Tile Progress",
                "type": "boolean"
              },
              "verbose": {
                "default": false,
                "title": "Verbose",
                "type": "boolean"
              },
              "predict_kwargs": {
                "title": "Predict Kwargs",
                "type": "object"
              },
              "nms_kwargs": {
                "title": "Nms Kwargs",
                "type": "object"
              }
            },
            "title": "StardistModelParams",
            "type": "object"
          },
          "StardistModels": {
            "description": "Enum for Stardist model names",
            "enum": [
              "2D_versatile_fluo",
              "2D_versatile_he",
              "2D_paper_dsb2018",
              "2D_demo",
              "3D_demo"
            ],
            "title": "StardistModels",
            "type": "string"
          },
          "StardistpretrainedModel": {
            "description": "Parameters to load a custom pretrained model",
            "properties": {
              "base_fld": {
                "title": "Base Fld",
                "type": "string"
              },
              "pretrained_model_name": {
                "title": "Pretrained Model Name",
                "type": "string"
              }
            },
            "required": [
              "base_fld",
              "pretrained_model_name"
            ],
            "title": "StardistpretrainedModel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "level": {
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be segmented. Choose `0` to process at full resolution."
          },
          "reference_acquisition": {
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "If provided, the task will only run stardist_segmentation for the reference_zarr_url."
          },
          "channel": {
            "$ref": "#/$defs/StardistChannelInputModel",
            "title": "Channel",
            "description": "Primary channel for segmentation; requires either `wavelength_id` (e.g. `A01_C01`) or `label` (e.g. `DAPI`), but not both. Also contains normalization options. By default, data is normalized so 0.0=1st percentile and 1.0=99th percentile of image intensities in each channel. This automatic normalization can lead to issues when the image to be segmented is very sparse. You can turn off the default rescaling. With the \"custom\" option, you can either provide your own rescaling percentiles or fixed rescaling upper and lower bound integers."
          },
          "input_ROI_table": {
            "default": "FOV_ROI_table",
            "title": "Input Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to apply stardist segmentation. Examples: `FOV_ROI_table` => loop over the field of views, `organoid_ROI_table` => loop over the organoid ROI table (generated by another task), `well_ROI_table` => process the whole well as one image."
          },
          "output_ROI_table": {
            "title": "Output Roi Table",
            "type": "string",
            "description": "If provided, a ROI table with that name is created, which will contain the bounding boxes of the newly segmented labels. ROI tables should have `ROI` in their name."
          },
          "output_label_name": {
            "title": "Output Label Name",
            "type": "string",
            "description": "Name of the output label image (e.g. `\"nuclei\"`)."
          },
          "model_type": {
            "allOf": [
              {
                "$ref": "#/$defs/StardistModels"
              }
            ],
            "default": "2D_versatile_fluo",
            "title": "Model Type",
            "description": "Parameter of `Stardist_ModelNames` class. Defines which model should be used. E.g. `2D_versatile_fluo`, `2D_versatile_he`, `2D_demo`, `3D_demo`."
          },
          "pretrained_model": {
            "allOf": [
              {
                "$ref": "#/$defs/StardistpretrainedModel"
              }
            ],
            "title": "Pretrained Model",
            "description": "Allows you to specify the path of a custom trained stardist model (takes precedence over `model_type`)"
          },
          "relabeling": {
            "default": true,
            "title": "Relabeling",
            "type": "boolean",
            "description": "If `True`, apply relabeling so that label values are unique for all objects in the well."
          },
          "use_masks": {
            "default": true,
            "title": "Use Masks",
            "type": "boolean",
            "description": "If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within `organoid_ROI_table`)."
          },
          "advanced_stardist_model_params": {
            "$ref": "#/$defs/StardistModelParams",
            "title": "Advanced Stardist Model Params",
            "description": "Advanced Stardist model parameters that are passed to the Stardist `model.eval` method."
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_url",
          "level",
          "channel"
        ],
        "type": "object",
        "title": "StardistSegmentation"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Seeded Watershed Segmentation",
      "category": "Segmentation",
      "tags": [
        "scikit-image",
        "itk,",
        "3D"
      ],
      "docs_info": "### Purpose\n- **Seeded Segmentation to retrieve e.g. Cell Segmentation**.\n- Accepts label_name of label image to use as seeds (e.g. nuclei) and single channel image input that contains boundary (e.g. membrane) marker.\n- Can process **arbitrary regions of interest (ROIs)**, including whole images, fields of view (FOVs), or masked outputs from prior segmentations, based on corresponding ROI tables.\n- If masked segmentation should be performed, use ROI table of type masking_roi_table.\n\n### Limitations\n- This task assumes that label_name and channel image are in same zarr_url.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/seeded_segmentation.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "$defs": {
          "FilterType": {
            "description": "Enum for image filter types",
            "enum": [
              "erosion",
              "dilation",
              "opening",
              "closing"
            ],
            "title": "FilterType",
            "type": "string"
          },
          "SeededSegmentationChannelInputModel": {
            "description": "Channel input for seeded segmentation with normalization options.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "string"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "normalize": {
                "$ref": "#/$defs/SeededSegmentationCustomNormalizer",
                "title": "Normalize"
              }
            },
            "title": "SeededSegmentationChannelInputModel",
            "type": "object"
          },
          "SeededSegmentationCustomNormalizer": {
            "description": "Validator to handle different normalization scenarios for seeded",
            "properties": {
              "norm_type": {
                "default": "no_normalization",
                "enum": [
                  "custom",
                  "no_normalization"
                ],
                "title": "Norm Type",
                "type": "string"
              },
              "lower_percentile": {
                "maximum": 100.0,
                "minimum": 0.0,
                "title": "Lower Percentile",
                "type": "number"
              },
              "upper_percentile": {
                "maximum": 100.0,
                "minimum": 0.0,
                "title": "Upper Percentile",
                "type": "number"
              },
              "lower_bound": {
                "title": "Lower Bound",
                "type": "integer"
              },
              "upper_bound": {
                "title": "Upper Bound",
                "type": "integer"
              }
            },
            "title": "SeededSegmentationCustomNormalizer",
            "type": "object"
          },
          "SeededSegmentationParams": {
            "description": "Advanced Seeded Segmentation Parameters.",
            "properties": {
              "filter_type": {
                "allOf": [
                  {
                    "$ref": "#/$defs/FilterType"
                  }
                ],
                "title": "Filter_Type"
              },
              "filter_value": {
                "title": "Filter Value",
                "type": "integer"
              },
              "filter_radius": {
                "title": "Filter Radius",
                "type": "integer"
              },
              "compactness": {
                "default": 0.0,
                "title": "Compactness",
                "type": "number"
              }
            },
            "title": "SeededSegmentationParams",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "level": {
            "title": "Level",
            "type": "integer",
            "description": "Pyramid level of the image to be segmented. Choose `0` to process at full resolution."
          },
          "reference_acquisition": {
            "title": "Reference Acquisition",
            "type": "integer",
            "description": "If provided, the task will only run seeded_segmentation for the reference_zarr_url."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Name of the label image to be used as input seeds. Expected to be in same zarr_url as channel image."
          },
          "channel": {
            "allOf": [
              {
                "$ref": "#/$defs/SeededSegmentationChannelInputModel"
              }
            ],
            "title": "Channel",
            "description": "Channel for segmentation; requires either `wavelength_id` (e.g. `A03_C03`) or `label` (e.g. `ECadherin`), but not both. Should contain the membrane marker. If no channel is provided, seeded segmentation is run with np.zeros as channel input. Also contains normalization options. Default is no normalization."
          },
          "input_ROI_table": {
            "default": "FOV_ROI_table",
            "title": "Input Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to apply seeded segmentation. Examples: `FOV_ROI_table` => loop over the field of views, `embryo_ROI_table` => loop over the organoid ROI table (generated by another task), `well_ROI_table` => process the whole well as one image. For seeded segmentation task it is recommended to use a ROI table of type `masking_roi_table`."
          },
          "output_ROI_table": {
            "title": "Output Roi Table",
            "type": "string",
            "description": "If provided, a ROI table with that name is created, which will contain the bounding boxes of the newly segmented labels. ROI tables should have `ROI` in their name."
          },
          "output_label_name": {
            "default": "cells",
            "title": "Output Label Name",
            "type": "string",
            "description": "Name of the output label image (e.g. `\"cells\"`)."
          },
          "relabeling": {
            "default": true,
            "title": "Relabeling",
            "type": "boolean",
            "description": "If `True`, apply relabeling so that label values are unique for all objects in the well."
          },
          "use_masks": {
            "default": true,
            "title": "Use Masks",
            "type": "boolean",
            "description": "If `True`, try to use masked loading and fall back to `use_masks=False` if the ROI table is not suitable. Masked loading is relevant when only a subset of the bounding box should actually be processed (e.g. running within `embryo_ROI_table`)."
          },
          "advanced_model_params": {
            "$ref": "#/$defs/SeededSegmentationParams",
            "title": "Advanced Model Params",
            "description": "Advanced model parameters for seeded segmentation."
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output."
          }
        },
        "required": [
          "zarr_url",
          "level",
          "label_name"
        ],
        "type": "object",
        "title": "SeededSegmentation"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Upsample Label Image",
      "category": "Image Processing",
      "tags": [
        "3D"
      ],
      "docs_info": "### Purpose\n- Upsamples segmented **labels** in 2D or 3D images to the highest image resolution.\n- Useful if segmentation was performed at a lower resolution (e.g. level 1).\n\n### Outputs\n- A new **upsampled label image** with resolution matching those of the OME-Zarr images.\n- Preserves the integer label values from the original segmentation.\n",
      "type": "parallel",
      "executable_parallel": "fractal_tasks/upsample_label_image.py",
      "meta_parallel": {
        "cpus_per_task": 4,
        "mem": 16000
      },
      "args_schema_parallel": {
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Path or url to the individual OME-Zarr image to be processed. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "label_name": {
            "title": "Label Name",
            "type": "string",
            "description": "Name of the label image to upsample."
          },
          "input_ROI_table": {
            "title": "Input Roi Table",
            "type": "string",
            "description": "Name of the ROI table over which the task loops to upsample label images. Examples: `FOV_ROI_table` => loop over the field of views, `organoid_ROI_table` => loop over the organoid ROI table (generated by another task), `well_ROI_table` => process the whole well as one image."
          },
          "output_label_name": {
            "title": "Output Label Name",
            "type": "string",
            "description": "Optionally new label name for the upsampled label image."
          },
          "output_ROI_table": {
            "title": "Output Roi Table",
            "type": "string",
            "description": "If provided, a ROI table with that name is created, which will contain the bounding boxes of the newly upsampled labels. ROI tables should have `ROI` in their name. Can be the same as `input_ROI_table` if it should be overwritten."
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "Desired pyramid level of the OME-Zarr label image. Pyramid level \"0\" resolution is retrieved from OME-Zarr image metadata. Currently only implemented for \"0\"."
          },
          "overwrite": {
            "default": true,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite existing label."
          }
        },
        "required": [
          "zarr_url",
          "label_name",
          "input_ROI_table"
        ],
        "type": "object",
        "title": "UpsampleLabelImage"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    },
    {
      "name": "Convert abbott-legacy H5 to OME-Zarr",
      "category": "Conversion",
      "modality": "HCS",
      "tags": [
        "Yokogawa",
        "Cellvoyager",
        "3D"
      ],
      "docs_info": "### Purpose\n- Converts Pelkmans-internal abbott-legacy h5 files to OME-Zarr.\n\n### Outputs\n- OME-Zarr directory with zarr_urls fitting Fractal convention.\n\n### Limitations\n- This task currently only supports 3D data with axes ZYX.\n",
      "type": "converter_compound",
      "executable_non_parallel": "fractal_tasks/convert_abbottlegacyh5_to_omezarr_init.py",
      "executable_parallel": "fractal_tasks/convert_abbottlegacyh5_to_omezarr_compute.py",
      "meta_non_parallel": {
        "cpus_per_task": 1,
        "mem": 4000
      },
      "meta_parallel": {
        "cpus_per_task": 16,
        "mem": 60000
      },
      "args_schema_non_parallel": {
        "$defs": {
          "AllowedH5Extensions": {
            "description": "Enum for allowed H5 file extensions.",
            "enum": [
              ".h5",
              ".hdf5"
            ],
            "title": "AllowedH5Extensions",
            "type": "string"
          },
          "ConverterMultiplexingAcquisition": {
            "description": "Input class for Multiplexing Cellvoyager converter",
            "properties": {
              "allowed_image_channels": {
                "items": {
                  "$ref": "#/$defs/ConverterOmeroChannel"
                },
                "title": "Allowed Image Channels",
                "type": "array"
              },
              "allowed_label_channels": {
                "items": {
                  "$ref": "#/$defs/ConverterOmeroChannel"
                },
                "title": "Allowed Label Channels",
                "type": "array"
              }
            },
            "required": [
              "allowed_image_channels"
            ],
            "title": "ConverterMultiplexingAcquisition",
            "type": "object"
          },
          "ConverterOmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "integer"
              },
              "index": {
                "title": "Index",
                "type": "integer"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "new_label": {
                "title": "New Label",
                "type": "string"
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "ConverterOmeroChannel",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_dir": {
            "title": "Zarr Dir",
            "type": "string",
            "description": "path of the directory where the new OME-Zarrs will be created. (standard argument for Fractal tasks, managed by Fractal server)."
          },
          "input_dir": {
            "title": "Input Dir",
            "type": "string",
            "description": "Input path to the folder containing H5 files to be converted."
          },
          "acquisitions": {
            "additionalProperties": {
              "$ref": "#/$defs/ConverterMultiplexingAcquisition"
            },
            "title": "Acquisitions",
            "type": "object",
            "description": "dictionary of acquisitions. Each key is the acquisition identifier (normally 0, 1, 2, 3 etc.). Each item defines the acquisition by providing the image_dir and the allowed_channels."
          },
          "include_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Include Glob Patterns",
            "type": "array",
            "description": "If specified, only parse images with filenames that match with all these patterns. Patterns must be defined as in https://docs.python.org/3/library/fnmatch.html, Example: `image_glob_pattern=[\"*_B03_*\"]` => only process well B03. Can interact with exclude_glob_patterns: All included images - all excluded images gives the final list of images to process"
          },
          "exclude_glob_patterns": {
            "items": {
              "type": "string"
            },
            "title": "Exclude Glob Patterns",
            "type": "array",
            "description": "If specified, exclude any image where the filename matches any of the exclusion patterns. Patterns are specified the same as for include_glob_patterns."
          },
          "h5_extension": {
            "allOf": [
              {
                "$ref": "#/$defs/AllowedH5Extensions"
              }
            ],
            "default": ".h5",
            "title": "H5 Extension",
            "description": "Filename extension of h5 files (e.g. `\"h5\"` or `\"hdf5\"`)."
          },
          "plate_name": {
            "default": "AssayPlate_Greiner_CELLSTAR655090",
            "title": "Plate Name",
            "type": "string",
            "description": "Name of the plate that was used to acquire the images."
          },
          "mrf_path": {
            "title": "Mrf Path",
            "type": "string",
            "description": "Provide path to cycle 0 mrf file, typically MeasurementDetail.mrf located in the raw image folder containing tif files."
          },
          "mlf_path": {
            "title": "Mlf Path",
            "type": "string",
            "description": "Same as for mrf, but for the mlf file. Typical name is MeasurementData.mlf."
          },
          "overwrite": {
            "default": false,
            "title": "Overwrite",
            "type": "boolean",
            "description": "If `True`, overwrite the task output. Default is `False`."
          }
        },
        "required": [
          "zarr_dir",
          "input_dir",
          "acquisitions",
          "mrf_path",
          "mlf_path"
        ],
        "type": "object",
        "title": "ConvertAbbottlegacyh5ToOmezarrInit"
      },
      "args_schema_parallel": {
        "$defs": {
          "ConverterMultiplexingAcquisition": {
            "description": "Input class for Multiplexing Cellvoyager converter",
            "properties": {
              "allowed_image_channels": {
                "items": {
                  "$ref": "#/$defs/ConverterOmeroChannel"
                },
                "title": "Allowed Image Channels",
                "type": "array"
              },
              "allowed_label_channels": {
                "items": {
                  "$ref": "#/$defs/ConverterOmeroChannel"
                },
                "title": "Allowed Label Channels",
                "type": "array"
              }
            },
            "required": [
              "allowed_image_channels"
            ],
            "title": "ConverterMultiplexingAcquisition",
            "type": "object"
          },
          "ConverterOMEZarrBuilderParams": {
            "description": "Parameters for the OME-Zarr builder.",
            "properties": {
              "number_multiscale": {
                "default": 4,
                "minimum": 0,
                "title": "Number Multiscale",
                "type": "integer"
              },
              "xy_scaling_factor": {
                "default": 2,
                "maximum": 10,
                "minimum": 1,
                "title": "Scaling Factor xy",
                "type": "integer"
              },
              "z_scaling_factor": {
                "default": 1,
                "maximum": 10,
                "minimum": 1,
                "title": "Z Scaling Factor",
                "type": "integer"
              },
              "max_xy_chunk": {
                "default": 4096,
                "minimum": 1,
                "title": "Max Xy Chunk",
                "type": "integer"
              },
              "z_chunk": {
                "default": 10,
                "minimum": 1,
                "title": "Z Chunk",
                "type": "integer"
              },
              "c_chunk": {
                "default": 1,
                "minimum": 1,
                "title": "C Chunk",
                "type": "integer"
              }
            },
            "title": "ConverterOMEZarrBuilderParams",
            "type": "object"
          },
          "ConverterOmeroChannel": {
            "description": "Custom class for Omero channels, based on OME-NGFF v0.4.",
            "properties": {
              "wavelength_id": {
                "title": "Wavelength Id",
                "type": "integer"
              },
              "index": {
                "title": "Index",
                "type": "integer"
              },
              "label": {
                "title": "Label",
                "type": "string"
              },
              "new_label": {
                "title": "New Label",
                "type": "string"
              }
            },
            "required": [
              "wavelength_id"
            ],
            "title": "ConverterOmeroChannel",
            "type": "object"
          },
          "ConverterWavelengthModel": {
            "description": "Input model for wavelength conversion.",
            "properties": {
              "wavelength_abbott_legacy": {
                "title": "Wavelength Abbott Legacy",
                "type": "integer"
              },
              "wavelength_omezarr": {
                "title": "Wavelength Omezarr",
                "type": "string"
              }
            },
            "required": [
              "wavelength_abbott_legacy",
              "wavelength_omezarr"
            ],
            "title": "ConverterWavelengthModel",
            "type": "object"
          },
          "CustomWavelengthInputModel": {
            "description": "Input model for the custom wavelength conversions to be used in task.",
            "properties": {
              "wavelengths": {
                "items": {
                  "$ref": "#/$defs/ConverterWavelengthModel"
                },
                "title": "Wavelengths",
                "type": "array"
              }
            },
            "title": "CustomWavelengthInputModel",
            "type": "object"
          },
          "InitArgsCellVoyagerH5toOMEZarr": {
            "description": "Arguments to be passed from cellvoyager converter init to compute",
            "properties": {
              "input_files": {
                "items": {
                  "type": "string"
                },
                "title": "Input Files",
                "type": "array"
              },
              "acquisition": {
                "$ref": "#/$defs/ConverterMultiplexingAcquisition",
                "title": "Acquisition"
              },
              "well_ID": {
                "title": "Well Id",
                "type": "string"
              },
              "plate_path": {
                "title": "Plate Path",
                "type": "string"
              },
              "mrf_path": {
                "title": "Mrf Path",
                "type": "string"
              },
              "mlf_path": {
                "title": "Mlf Path",
                "type": "string"
              },
              "overwrite": {
                "title": "Overwrite",
                "type": "boolean"
              }
            },
            "required": [
              "input_files",
              "acquisition",
              "well_ID",
              "plate_path",
              "mrf_path",
              "mlf_path",
              "overwrite"
            ],
            "title": "InitArgsCellVoyagerH5toOMEZarr",
            "type": "object"
          }
        },
        "additionalProperties": false,
        "properties": {
          "zarr_url": {
            "title": "Zarr Url",
            "type": "string",
            "description": "Output path to save the OME-Zarr file of the form `zarr_dir/plate_name/row/column/`."
          },
          "init_args": {
            "$ref": "#/$defs/InitArgsCellVoyagerH5toOMEZarr",
            "title": "Init Args",
            "description": "Initialization arguments passed from init task."
          },
          "level": {
            "default": 0,
            "title": "Level",
            "type": "integer",
            "description": "The level of the image to convert. Currently only level 0 is supported."
          },
          "wavelengths": {
            "allOf": [
              {
                "$ref": "#/$defs/CustomWavelengthInputModel"
              }
            ],
            "default": {
              "wavelengths": [
                {
                  "wavelength_abbott_legacy": 405,
                  "wavelength_omezarr": "A01_C01"
                },
                {
                  "wavelength_abbott_legacy": 488,
                  "wavelength_omezarr": "A02_C02"
                },
                {
                  "wavelength_abbott_legacy": 561,
                  "wavelength_omezarr": "A03_C03"
                },
                {
                  "wavelength_abbott_legacy": 640,
                  "wavelength_omezarr": "A04_C04"
                }
              ]
            },
            "title": "Wavelengths",
            "description": "Wavelength conversion dictionary mapping."
          },
          "axes_names": {
            "default": "ZYX",
            "title": "Axes Names",
            "type": "string",
            "description": "The layout of the image data. Currently only implemented for 'ZYX'."
          },
          "ome_zarr_parameters": {
            "allOf": [
              {
                "$ref": "#/$defs/ConverterOMEZarrBuilderParams"
              }
            ],
            "default": {
              "number_multiscale": 4,
              "xy_scaling_factor": 2,
              "z_scaling_factor": 1,
              "max_xy_chunk": 4096,
              "z_chunk": 10,
              "c_chunk": 1
            },
            "title": "Ome Zarr Parameters",
            "description": "Parameters for the OME-Zarr builder."
          },
          "masking_label": {
            "title": "Masking Label",
            "type": "string",
            "description": "Optional label for masking ROI e.g. `embryo`."
          }
        },
        "required": [
          "zarr_url",
          "init_args"
        ],
        "type": "object",
        "title": "ConvertAbbottlegacyh5ToOmezarrCompute"
      },
      "docs_link": "https://github.com/pelkmanslab/abbott"
    }
  ],
  "has_args_schemas": true,
  "args_schema_version": "pydantic_v2",
  "authors": "Ruth Hornbachner"
}
